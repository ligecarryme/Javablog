2020-10-13 22:20:53.692  INFO 27820 --- [restartedMain] com.darin.blog.BlogApplication           : Starting BlogApplication on LAPTOP-AAV7U5VL with PID 27820 (E:\Code\JavaProjects\myblog\target\classes started by admin in E:\Code\JavaProjects\myblog)
2020-10-13 22:20:53.699 DEBUG 27820 --- [restartedMain] com.darin.blog.BlogApplication           : Running with Spring Boot v2.3.4.RELEASE, Spring v5.2.9.RELEASE
2020-10-13 22:20:53.700  INFO 27820 --- [restartedMain] com.darin.blog.BlogApplication           : No active profile set, falling back to default profiles: default
2020-10-13 22:20:53.765  INFO 27820 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-10-13 22:20:53.766  INFO 27820 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-10-13 22:20:56.105  INFO 27820 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFERRED mode.
2020-10-13 22:20:56.334  INFO 27820 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 205ms. Found 4 JPA repository interfaces.
2020-10-13 22:20:58.645  INFO 27820 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8079 (http)
2020-10-13 22:20:58.671  INFO 27820 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-10-13 22:20:58.672  INFO 27820 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.38]
2020-10-13 22:20:58.990  INFO 27820 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-10-13 22:20:58.991  INFO 27820 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 5225 ms
2020-10-13 22:20:59.461  INFO 27820 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-10-13 22:20:59.685  INFO 27820 --- [task-1] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-10-13 22:20:59.861  INFO 27820 --- [task-1] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.21.Final
2020-10-13 22:21:00.306  INFO 27820 --- [task-1] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-10-13 22:21:00.667  INFO 27820 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-10-13 22:21:00.922  WARN 27820 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-10-13 22:21:01.613  INFO 27820 --- [restartedMain] pertySourcedRequestMappingHandlerMapping : Mapped URL path [/v2/api-docs] onto method [springfox.documentation.swagger2.web.Swagger2Controller#getDocumentation(String, HttpServletRequest)]
2020-10-13 22:21:02.516  INFO 27820 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-10-13 22:21:03.184  INFO 27820 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-10-13 22:21:03.236  INFO 27820 --- [task-1] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-10-13 22:21:03.266  INFO 27820 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8079 (http) with context path ''
2020-10-13 22:21:03.269  INFO 27820 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Context refreshed
2020-10-13 22:21:03.319  INFO 27820 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Found 1 custom documentation plugin(s)
2020-10-13 22:21:03.403  INFO 27820 --- [restartedMain] s.d.s.w.s.ApiListingReferenceScanner     : Scanning for api listing references
2020-10-13 22:21:03.954  INFO 27820 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: deleteUsingGET_1
2020-10-13 22:21:04.005  INFO 27820 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: postUsingPOST_1
2020-10-13 22:21:04.039  INFO 27820 --- [restartedMain] DeferredRepositoryInitializationListener : Triggering deferred initialization of Spring Data repositories…
2020-10-13 22:21:05.608  INFO 27820 --- [task-1] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-10-13 22:21:05.627  INFO 27820 --- [task-1] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-10-13 22:21:07.365  INFO 27820 --- [restartedMain] DeferredRepositoryInitializationListener : Spring Data repositories initialized!
2020-10-13 22:21:07.384  INFO 27820 --- [restartedMain] com.darin.blog.BlogApplication           : Started BlogApplication in 14.383 seconds (JVM running for 16.313)
2020-10-13 22:21:20.548  INFO 27820 --- [http-nio-8079-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-10-13 22:21:20.549  INFO 27820 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-10-13 22:21:20.574  INFO 27820 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 25 ms
2020-10-13 22:21:21.785  INFO 27820 --- [http-nio-8079-exec-1] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='0:0:0:0:0:0:0:1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:21:22.022  WARN 27820 --- [http-nio-8079-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 22:21:22.057  WARN 27820 --- [http-nio-8079-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 22:21:22.065  INFO 27820 --- [http-nio-8079-exec-1] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}, Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}, Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]}
2020-10-13 22:21:28.735  INFO 27820 --- [http-nio-8079-exec-5] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='0:0:0:0:0:0:0:1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:21:28.758  INFO 27820 --- [http-nio-8079-exec-5] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}, Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}, Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]}
2020-10-13 22:31:33.708  INFO 42256 --- [restartedMain] com.darin.blog.BlogApplication           : Starting BlogApplication on LAPTOP-AAV7U5VL with PID 42256 (E:\Code\JavaProjects\myblog\target\classes started by admin in E:\Code\JavaProjects\myblog)
2020-10-13 22:31:33.713 DEBUG 42256 --- [restartedMain] com.darin.blog.BlogApplication           : Running with Spring Boot v2.3.4.RELEASE, Spring v5.2.9.RELEASE
2020-10-13 22:31:33.713  INFO 42256 --- [restartedMain] com.darin.blog.BlogApplication           : No active profile set, falling back to default profiles: default
2020-10-13 22:31:33.790  INFO 42256 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-10-13 22:31:33.790  INFO 42256 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-10-13 22:31:34.906  INFO 42256 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFERRED mode.
2020-10-13 22:31:35.001  INFO 42256 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 87ms. Found 4 JPA repository interfaces.
2020-10-13 22:31:36.226  INFO 42256 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8079 (http)
2020-10-13 22:31:36.247  INFO 42256 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-10-13 22:31:36.248  INFO 42256 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.38]
2020-10-13 22:31:36.559  INFO 42256 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-10-13 22:31:36.561  INFO 42256 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2770 ms
2020-10-13 22:31:36.987  INFO 42256 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-10-13 22:31:37.196  INFO 42256 --- [task-1] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-10-13 22:31:37.296  INFO 42256 --- [task-1] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.21.Final
2020-10-13 22:31:37.595  INFO 42256 --- [task-1] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-10-13 22:31:37.826  INFO 42256 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-10-13 22:31:38.065  WARN 42256 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-10-13 22:31:38.760  INFO 42256 --- [restartedMain] pertySourcedRequestMappingHandlerMapping : Mapped URL path [/v2/api-docs] onto method [springfox.documentation.swagger2.web.Swagger2Controller#getDocumentation(String, HttpServletRequest)]
2020-10-13 22:31:39.439  INFO 42256 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-10-13 22:31:39.951  INFO 42256 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-10-13 22:31:39.980  INFO 42256 --- [task-1] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-10-13 22:31:40.058  INFO 42256 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8079 (http) with context path ''
2020-10-13 22:31:40.067  INFO 42256 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Context refreshed
2020-10-13 22:31:40.144  INFO 42256 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Found 1 custom documentation plugin(s)
2020-10-13 22:31:40.237  INFO 42256 --- [http-nio-8079-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-10-13 22:31:40.238  INFO 42256 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-10-13 22:31:40.252  INFO 42256 --- [restartedMain] s.d.s.w.s.ApiListingReferenceScanner     : Scanning for api listing references
2020-10-13 22:31:40.274  INFO 42256 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 35 ms
2020-10-13 22:31:40.777  INFO 42256 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: deleteUsingGET_1
2020-10-13 22:31:40.787  INFO 42256 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: postUsingPOST_1
2020-10-13 22:31:40.819  INFO 42256 --- [restartedMain] DeferredRepositoryInitializationListener : Triggering deferred initialization of Spring Data repositories…
2020-10-13 22:31:41.816  INFO 42256 --- [task-1] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-10-13 22:31:41.829  INFO 42256 --- [task-1] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-10-13 22:31:43.123  INFO 42256 --- [restartedMain] DeferredRepositoryInitializationListener : Spring Data repositories initialized!
2020-10-13 22:31:43.144  INFO 42256 --- [restartedMain] com.darin.blog.BlogApplication           : Started BlogApplication in 10.057 seconds (JVM running for 11.743)
2020-10-13 22:31:43.662  INFO 42256 --- [http-nio-8079-exec-10] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='127.0.0.1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:31:43.902  WARN 42256 --- [http-nio-8079-exec-10] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 22:31:43.931  WARN 42256 --- [http-nio-8079-exec-10] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 22:31:43.936  INFO 42256 --- [http-nio-8079-exec-10] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}], [Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}], [Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]]}
2020-10-13 22:32:30.129  INFO 42256 --- [http-nio-8079-exec-1] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='127.0.0.1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:32:30.154  INFO 42256 --- [http-nio-8079-exec-1] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}], [Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}], [Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]]}
2020-10-13 22:34:50.898  INFO 42256 --- [http-nio-8079-exec-7] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='0:0:0:0:0:0:0:1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:34:50.919  INFO 42256 --- [http-nio-8079-exec-7] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}], [Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}], [Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]]}
2020-10-13 22:35:18.969  INFO 42256 --- [http-nio-8079-exec-1] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='0:0:0:0:0:0:0:1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:35:18.991  INFO 42256 --- [http-nio-8079-exec-1] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}], [Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}], [Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]]}
2020-10-13 22:36:34.554  INFO 36720 --- [restartedMain] com.darin.blog.BlogApplication           : Starting BlogApplication on LAPTOP-AAV7U5VL with PID 36720 (E:\Code\JavaProjects\myblog\target\classes started by admin in E:\Code\JavaProjects\myblog)
2020-10-13 22:36:34.559 DEBUG 36720 --- [restartedMain] com.darin.blog.BlogApplication           : Running with Spring Boot v2.3.4.RELEASE, Spring v5.2.9.RELEASE
2020-10-13 22:36:34.560  INFO 36720 --- [restartedMain] com.darin.blog.BlogApplication           : No active profile set, falling back to default profiles: default
2020-10-13 22:36:34.606  INFO 36720 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-10-13 22:36:34.606  INFO 36720 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-10-13 22:36:35.934  INFO 36720 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFERRED mode.
2020-10-13 22:36:36.003  INFO 36720 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 61ms. Found 4 JPA repository interfaces.
2020-10-13 22:36:37.410  INFO 36720 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8079 (http)
2020-10-13 22:36:37.441  INFO 36720 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-10-13 22:36:37.442  INFO 36720 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.38]
2020-10-13 22:36:37.624  INFO 36720 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-10-13 22:36:37.624  INFO 36720 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3018 ms
2020-10-13 22:36:37.913  INFO 36720 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-10-13 22:36:37.970  INFO 36720 --- [task-1] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-10-13 22:36:38.060  INFO 36720 --- [task-1] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.21.Final
2020-10-13 22:36:38.188  INFO 36720 --- [task-1] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-10-13 22:36:38.275  INFO 36720 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-10-13 22:36:38.340  WARN 36720 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-10-13 22:36:38.543  INFO 36720 --- [restartedMain] pertySourcedRequestMappingHandlerMapping : Mapped URL path [/v2/api-docs] onto method [springfox.documentation.swagger2.web.Swagger2Controller#getDocumentation(String, HttpServletRequest)]
2020-10-13 22:36:38.762  INFO 36720 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-10-13 22:36:39.095  INFO 36720 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8079 (http) with context path ''
2020-10-13 22:36:39.096  INFO 36720 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Context refreshed
2020-10-13 22:36:39.113  INFO 36720 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Found 1 custom documentation plugin(s)
2020-10-13 22:36:39.151  INFO 36720 --- [restartedMain] s.d.s.w.s.ApiListingReferenceScanner     : Scanning for api listing references
2020-10-13 22:36:39.165  INFO 36720 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-10-13 22:36:39.189  INFO 36720 --- [task-1] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-10-13 22:36:39.530  INFO 36720 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: deleteUsingGET_1
2020-10-13 22:36:39.540  INFO 36720 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: postUsingPOST_1
2020-10-13 22:36:39.556  INFO 36720 --- [restartedMain] DeferredRepositoryInitializationListener : Triggering deferred initialization of Spring Data repositories…
2020-10-13 22:36:40.155  INFO 36720 --- [task-1] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-10-13 22:36:40.165  INFO 36720 --- [task-1] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-10-13 22:36:40.962  INFO 36720 --- [restartedMain] DeferredRepositoryInitializationListener : Spring Data repositories initialized!
2020-10-13 22:36:40.972  INFO 36720 --- [restartedMain] com.darin.blog.BlogApplication           : Started BlogApplication in 6.962 seconds (JVM running for 8.548)
2020-10-13 22:36:44.574  INFO 36720 --- [http-nio-8079-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-10-13 22:36:44.575  INFO 36720 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-10-13 22:36:44.598  INFO 36720 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 23 ms
2020-10-13 22:36:45.701 ERROR 36720 --- [http-nio-8079-exec-5] c.d.b.h.ControllerExceptionHandler       : Request URL: http://localhost:8079/, Exception: {}

org.springframework.web.bind.MissingServletRequestParameterException: Required Integer parameter 'currentPage' is not present
	at org.springframework.web.method.annotation.RequestParamMethodArgumentResolver.handleMissingValue(RequestParamMethodArgumentResolver.java:204)
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:114)
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

2020-10-13 22:36:45.705  WARN 36720 --- [http-nio-8079-exec-5] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.web.bind.MissingServletRequestParameterException: Required Integer parameter 'currentPage' is not present]
2020-10-13 22:36:45.722 ERROR 36720 --- [http-nio-8079-exec-5] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Circular view path []: would dispatch back to the current handler URL [/] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)] with root cause

javax.servlet.ServletException: Circular view path []: would dispatch back to the current handler URL [/] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)
	at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:210)
	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:148)
	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:316)
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373)
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

2020-10-13 22:37:05.730  INFO 36720 --- [http-nio-8079-exec-4] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='0:0:0:0:0:0:0:1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 22:37:05.953  WARN 36720 --- [http-nio-8079-exec-4] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 22:37:05.984  WARN 36720 --- [http-nio-8079-exec-4] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 22:37:05.992  INFO 36720 --- [http-nio-8079-exec-4] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data=[[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}], [Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}], [Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]]}
2020-10-13 23:17:36.903  INFO 38948 --- [restartedMain] com.darin.blog.BlogApplication           : Starting BlogApplication on LAPTOP-AAV7U5VL with PID 38948 (E:\Code\JavaProjects\myblog\target\classes started by admin in E:\Code\JavaProjects\myblog)
2020-10-13 23:17:36.909 DEBUG 38948 --- [restartedMain] com.darin.blog.BlogApplication           : Running with Spring Boot v2.3.4.RELEASE, Spring v5.2.9.RELEASE
2020-10-13 23:17:36.910  INFO 38948 --- [restartedMain] com.darin.blog.BlogApplication           : No active profile set, falling back to default profiles: default
2020-10-13 23:17:37.014  INFO 38948 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-10-13 23:17:37.015  INFO 38948 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-10-13 23:17:38.838  INFO 38948 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFERRED mode.
2020-10-13 23:17:39.007  INFO 38948 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 153ms. Found 4 JPA repository interfaces.
2020-10-13 23:17:40.552  INFO 38948 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8079 (http)
2020-10-13 23:17:40.571  INFO 38948 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-10-13 23:17:40.572  INFO 38948 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.38]
2020-10-13 23:17:40.830  INFO 38948 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-10-13 23:17:40.831  INFO 38948 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3816 ms
2020-10-13 23:17:41.192  INFO 38948 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-10-13 23:17:41.396  INFO 38948 --- [task-1] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-10-13 23:17:41.499  INFO 38948 --- [task-1] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.21.Final
2020-10-13 23:17:41.791  INFO 38948 --- [task-1] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-10-13 23:17:42.009  INFO 38948 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-10-13 23:17:42.199  WARN 38948 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-10-13 23:17:42.763  INFO 38948 --- [restartedMain] pertySourcedRequestMappingHandlerMapping : Mapped URL path [/v2/api-docs] onto method [springfox.documentation.swagger2.web.Swagger2Controller#getDocumentation(String, HttpServletRequest)]
2020-10-13 23:17:43.475  INFO 38948 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-10-13 23:17:43.941  INFO 38948 --- [task-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-10-13 23:17:43.988  INFO 38948 --- [task-1] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-10-13 23:17:44.099  INFO 38948 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8079 (http) with context path ''
2020-10-13 23:17:44.102  INFO 38948 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Context refreshed
2020-10-13 23:17:44.141  INFO 38948 --- [restartedMain] d.s.w.p.DocumentationPluginsBootstrapper : Found 1 custom documentation plugin(s)
2020-10-13 23:17:44.221  INFO 38948 --- [restartedMain] s.d.s.w.s.ApiListingReferenceScanner     : Scanning for api listing references
2020-10-13 23:17:44.618  INFO 38948 --- [http-nio-8079-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-10-13 23:17:44.618  INFO 38948 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-10-13 23:17:44.664  INFO 38948 --- [http-nio-8079-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 45 ms
2020-10-13 23:17:44.747  INFO 38948 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: deleteUsingGET_1
2020-10-13 23:17:44.760  INFO 38948 --- [restartedMain] .d.s.w.r.o.CachingOperationNameGenerator : Generating unique operation named: postUsingPOST_1
2020-10-13 23:17:44.791  INFO 38948 --- [restartedMain] DeferredRepositoryInitializationListener : Triggering deferred initialization of Spring Data repositories…
2020-10-13 23:17:45.743  INFO 38948 --- [task-1] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-10-13 23:17:45.757  INFO 38948 --- [task-1] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-10-13 23:17:46.966  INFO 38948 --- [restartedMain] DeferredRepositoryInitializationListener : Spring Data repositories initialized!
2020-10-13 23:17:46.987  INFO 38948 --- [restartedMain] com.darin.blog.BlogApplication           : Started BlogApplication in 11.202 seconds (JVM running for 14.824)
2020-10-13 23:17:47.321 ERROR 38948 --- [http-nio-8079-exec-9] c.d.b.h.ControllerExceptionHandler       : Request URL: http://localhost:8079/, Exception: {}

org.springframework.web.bind.MissingServletRequestParameterException: Required Integer parameter 'currentPage' is not present
	at org.springframework.web.method.annotation.RequestParamMethodArgumentResolver.handleMissingValue(RequestParamMethodArgumentResolver.java:204)
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:114)
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

2020-10-13 23:17:47.325  WARN 38948 --- [http-nio-8079-exec-9] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.web.bind.MissingServletRequestParameterException: Required Integer parameter 'currentPage' is not present]
2020-10-13 23:17:47.355 ERROR 38948 --- [http-nio-8079-exec-9] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Circular view path []: would dispatch back to the current handler URL [/] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)] with root cause

javax.servlet.ServletException: Circular view path []: would dispatch back to the current handler URL [/] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)
	at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:210)
	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:148)
	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:316)
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373)
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

2020-10-13 23:17:54.184  INFO 38948 --- [http-nio-8079-exec-7] com.darin.blog.aspect.LogAspect          : Request : RequestLog{url='http://localhost:8079/', ip='0:0:0:0:0:0:0:1', classMethod='com.darin.blog.controller.IndexController.index', args=[1]}
2020-10-13 23:17:54.405  WARN 38948 --- [http-nio-8079-exec-7] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 23:17:54.426  WARN 38948 --- [http-nio-8079-exec-7] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-10-13 23:17:54.433  INFO 38948 --- [http-nio-8079-exec-7] com.darin.blog.aspect.LogAspect          : Result : CommonResult{code=200, message='获取成功', data={blog=[Blog{id=11, title='Java概述', content='### 1 Java 概述

Java介于编译型语言和解释型语言之间。Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。

JDK（java开发工具包）包含JRE，JRE(Java Runtime Environment)包括Java虚拟机（JVM）和Java程序所需的核心类库等。

![jdk](https://gitee.com/darinx/blog-img/raw/master/img/JDK.jpg)

#### 1.1 Java特点

面向对象（封装、继承、多态）。平台无关性。支持网络编程且很方便。支持多线程。健壮性、安全性。

.class字节码文件，由虚拟机解释执行，无须重新编译便可在不同计算机上运行。

Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

#### 1.2 关键字

**final**修饰的类不可以被继承、被重写；修饰的变量不可被改变，是一个常量不可以被重新赋值。

```java
final double PI = 3.14;
PI = 3 // 编译错误
```

（finally用在try-catch代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。finalize是一个方法，属于Object类的一个方法，由垃圾回收器调用finalize()，回收垃圾。）

**this**自身的一个对象，可理解为：指向对象本身的一个指针。

**super**可理解为指向自己父类对象的一个指针。

**static**创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。因为其特性：只会在类加载的时候执行一次。

#### 1.3 基础数据类型（值类型）

- 整数类型：byte，short，int，long  
- 浮点数类型：float，double
- 字符类型：char
- 布尔类型：boolean

<img src="https://gitee.com/darinx/blog-img/raw/master/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" />

byte一个字节 8 bit，int类型 32 位

#### 1.4 >> and >>>（无符号右移运算）and &（与）、|（或）、~（非）、^（异或）

对整数进行右移：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

对负数进行右移：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

**与（&）运算**的规则是，必须两个数同时为1，结果才为1。
**或（|）运算**的规则是，只要任意一个为1，结果就为1。
**非（~）运算**的规则是，0和1互换。
**异或（^）运算**的规则是，如果两个数不同，结果为1，否则为0。

#### 1.5 引用类型

由类型的实际值引用（类似于指针）表示的数据类型。判断引用类型的变量内容是否相等，必须使用`equals()`方法。

==数组是引用类型==，并且数组大小不可变。

```java
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns.png"/>

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个新的3个元素的数组：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/ns2.png"/>

原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。

==字符串也是引用类型==，先定义一个字符串数组：

```java
String[] names = {"ABC", "XYZ", "zoo"};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st1.png" style="zoom:100%;" align="left" />

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

<img src="https://gitee.com/darinx/blog-img/raw/master/img/st2.png" style="zoom:100%;" align="left"/>

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。

```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"ABC", "XYZ", "zoo"};
        String s = names[1];
        names[1] = "cat";
        System.out.println(s); // s是"XYZ"还是"cat"? -----> "XYZ" s指针指向”XYZ“
    }
}
```

#### 1.6 输入和输出

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.in标准输入流
        System.out.print("Input your name: "); // 打印提示
        String name = scanner.nextLine(); // 读取一行输入并获取字符串
        System.out.print("Input your age: "); // 打印提示
        int age = scanner.nextInt(); // 读取一行输入并获取整数
        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出
    }
}
```

### 2 面向对象

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。

**方法**：

```java
class Person {
    private int age; //不使用public是为了避免外部代码直接去访问field
    				 //public int age;
					 //person.age=10; // ×
    
    public int getAge() {
        return this.age;
    }

    public void setAge(int age) { // person.setAge(10);
        this.age = age;			  // sout(person.getAge()); 推荐
    }
}
```



**封装**：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

**继承**：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**多态性**：多态指同一个行为具有多个不同表现形式或形态的能力。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。



### 3 类与接口

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

**接口**`interface`，是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}

interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

抽象类和接口的区别：

|            | abstract class       | interface                   |
| :--------- | :------------------- | --------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

为什么要用抽象类和接口

内部类，可以将一个类的定义放在另外一个类的定义内部。内部类本身就是类的一个属性，分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='java 概述，主要包括基础数据类型、面向对象思想、抽象类和接口。', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:43:23.652, updateTime=2020-10-12 22:35:08.236}, Blog{id=12, title='JS 入门', content='### 入门

#### 数据类型和变量

数据类型：Number、字符串、布尔值、比较运算符、null和undefined、对象、变量。

1、Js不区分整数和浮点数，统一用Number表示。

```javascript
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

2、比较运算符（特别注意相等运算符`==`）

```javascript
false == 0; // true
false === 0; //false
```

> 第一种 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
>
> 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。
>
> 由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```javascript
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```javascript
isNaN(NaN); // true
```

浮点数的相等比较，计算他们之差的绝对值

```javascript
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

3、null 和 undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

有一个和`null`类似的`undefined`，它表示“未定义”。JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

4、数组

JavaScript的数组可以包括任意数据类型。**强烈建议**直接使用`[]`创建数组。

```javascript
var arr = [1, 2, 3.14, 'Hello', null, true]; // 数组用[]表示，元素之间用,分隔。
另一种方法是通过Aarry()函数实现：
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```

5、对象

JavaScript的对象是一组由键-值组成的无序集合，JavaScript对象的键都是字符串类型，值可以是任意数据类型。

```javascript
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```javascript
person.name; // 'Bob'
person.zipcode; // null
```

6、变量

可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次。不用`var`申明的变量会被视为全局变量。`var`局部变量

```javascript
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，而静态语言在定义变量时必须指定变量类型。

#### 字符串

Js的字符串就是用 `''`或者 `""`括起来的字符表示。

1、如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识

```javascript
'I\'m \"OK\"!';  \\表示的字符串内容是：I'm "OK"!
```

2、多行字符串，用反引号 *`\* ... \*`* 表示：

```javascript
`这是一个
多行
字符串`;
```

3、把多个字符串连接起来，可以用`+`号连接：

```javascript
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
```

ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var message = `你好, ${name}, 你今年${age}岁了!`;//ES6新增
```

4、操作字符串

```js
var s = 'Hello, world!';
s.length; // 长度
s.toUpperCase(); // 把一个字符串全部变为大写
s.toLowerCase();// 把一个字符串全部变为小写
s.indexOf('world');// 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

==需要特别注意的是==，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

#### 数组

==数组方法==：

1、`indexOf` 搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

2、`slice()` 就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`，`slice()`的起止参数包括开始索引，不包括结束索引。如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

3、`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
```

4、如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
```

5、`sort()`可以对当前`Array`进行排序。

6、`reverse()`把整个`Array`的元素给掉个个，也就是反转

7、`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

8、`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`，

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

9、`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

10、多维数组

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

#### 对象

如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

> 不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：
>
> ```js
> 'toString' in xiaoming; // true
> ```

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

JavaScript 中的 Boolean 类型：true 和 false

==JavaScript== 把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`

#### 循环

`for (i=1; i<=10000; i++) {}`

`for ... in`循环，它可以把一个对象的所有属性依次循环出来，*注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

`while` 和 `do { ... } while()`

#### Map和Set

ES6规范引入了新的数据类型`Map`

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

`Set`和`Map`类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在`Set`中，没有重复的key。

创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
var s = new Set([1, 2, 3, 3, '3']); //重复元素在Set中自动被过滤,数字3和字符串'3'是不同元素
s; // Set {1, 2, 3, "3"}
```

通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果；通过`delete(key)`方法可以删除元素：

#### iterable

ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。

具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。

```js
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```

> `for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：
>
> ```js
> var a = ['A', 'B', 'C'];
> a.name = 'Hello';
> for (var x in a) {
>  console.log(x); // '0', '1', '2', 'name'
> }
> ```
>
> `for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

然而，**更好的方式**是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
a.forEach(function (element, index, array) { 	// element: 指向当前元素的值
    console.log(element + ', index = ' + index);// index: 指向当前索引
});   											// array: 指向Array对象本身
A, index = 0 、 B, index = 1 、 C, index = 2
```

...', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:45:45.053, updateTime=2020-10-11 20:45:45.053}, Blog{id=13, title='函数', content='### 定义函数

Javascript 中定义函数的方式：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

如果没有return语句，函数执行完毕后也回返回结果，只是结果为undefined。由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

第二种定义函数的方式：

```js
var abs = function (x) {}
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

#### 调用函数

JavaScript允许传入任意个参数而不影响调用

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

##### 关键字`arguments`

它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
结果：
x = 10
arg 0 = 10
arg 1 = 20
arg 2 = 30
```

`arguments`最常用于判断传入参数的个数：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### ES6 标准引入了rest参数

函数获得额外的参数放到`rest`中。`rest`相当于数组。

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

### 变量作用域与解构赋值

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。JS默认有一个全局对象window。全局作用域的变量实际上被绑定到`window`的一个属性：

```js
var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript' 直接访问全局变量course和访问window.course完全一样
```

#### 局部作用域

var的作用域是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
function foo() {
    for (var i=0; i<100; i++) { }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量。

```js
function foo() {
    for (let i=0; i<100; i++) { }
    i += 100; // SyntaxError(语法错误)
}
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

#### 解构赋值

传统做法，把一个数组的元素分别赋值给几个变量：

```js
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```

在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```js
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, age, passport} = person;
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
结果： name = 小明, age = 20, passport = G-12345678

var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```

##### 使用场景

1、交换两个变量`x`和`y`的值

```js
var x=1, y=2;
[x, y] = [y, x]
```

2、快速获取当前页面的域名和路径：

```js
var {hostname:domain, pathname:path} = location;
```

### 方法

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

在函数内部定义的函数，用一个`that`变量首先捕获`this`。

**apply 方法**

指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 高阶函数

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数（Higher-order function）。

```js
function add(x, y, f) {
    return f(x) + f(y);
}
//当我们调用add(-5, 6, Math.abs)时
计算过程：
x = -5; y = 6; f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

#### map函数

`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); 
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce函数

Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25 求和
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579 变成整数
```

#### filter函数

它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。（true保留）

```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];  //删掉偶数，只保留奇数
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

#### sort函数

`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`

通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

```js
var arr=[10,20,1,2]
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

#### every函数

`every()`方法可以判断数组的所有元素是否满足测试条件，满足返回`true`，不满足返回`false`

#### find函数

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`

#### findIndex函数

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`

#### forEach函数

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

### 闭包

```js
(function (x) { 
    return x * x;
})(3); // 9  创建匿名函数并立即执行
```

闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}

var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

### 箭头函数

```js
x => x*x
```

如果参数不止一个，就需要用括号（）括起来

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
		⭐ var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();  //30
    }
};
```

箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`。

### Generator生成器

函数定义如下：

```js
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```

generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

```js
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];  //普通写法
        arr.push(b);
    }
    return arr;
    
  ⭐ while (n < max) {
        yield a;   //生成器写法
        [a, b] = [b, a + b];
        n ++;
    }
    return;  
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 调用
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
// 第一种调用方法 next()
var f = fib(5)
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
···
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
// 第二种调用方法 for...of
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```

`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

generator 可以把异步回调函数代码变成“同步”代码。

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
} //看上去是同步的代码，实际执行是异步的。
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=true, recommend=true, createTime=2020-10-11 20:46:24.301, updateTime=2020-10-11 20:46:24.301}, Blog{id=14, title='JS 标准对象', content='### 标准对象

用`typeof`操作符获取对象的类型。

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object' 对象
typeof []; // 'object'
typeof {}; // 'object'
```

需要遵守的几条规则

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

应该这样写

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

#### Date

`Date`对象用来表示日期和时间

```js
var now = new Date(); //获取系统当前时间
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 ⭐
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00'); //使用Date.parse()时传入的字符串使用实际月份01~12
d; // 1435146562875
var dd = new Date(1435146562875)
dd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

#### RegExp

正则表达式，默认贪婪匹配。https://www.liaoxuefeng.com/wiki/1022910821149312/1023021582119488

Js创建一个正则表达式：第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

```js
var re1 = /ABC\-001/; 
var re2 = new RegExp('ABC\\-001'); //因为字符串的转义问题，字符串的两个\\实际上是一个\。
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
```

##### 切分字符串

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c'] 正常的切分
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] 用正则表达式
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

##### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

##### 全局搜索（g）

```js
var r1 = /test/g; // 等价于下式:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

#### JSON

在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8。

```js
var s = JSON.stringify(xiaoming)
console.log(s)
//{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}

JSON.stringify(xiaoming,null,' '); //按缩进输出 
JSON.stringify(xiaoming, ['name', 'skills'], '  '); //控制如何筛选对象的键值，如果我们只想输出指定的属性
```

#### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

', firstPicture='https://picsum.photos/200/300', flag='原创', views=0, description='null', appreciation=true, shareStatement=false, commentabled=true, published=false, recommend=true, createTime=2020-10-11 20:49:20.123, updateTime=2020-10-11 20:49:20.123}], type=[Type{id=1, name='学习'}, Type{id=2, name='算法'}, Type{id=3, name='生活'}], tag=[Tag{id=5, name='JavaScript'}, Tag{id=8, name='Java'}, Tag{id=4, name='Vue'}, Tag{id=6, name='Html'}, Tag{id=7, name='CSS3'}, Tag{id=9, name='Spring Boot'}, Tag{id=10, name='Element UI'}]}}
